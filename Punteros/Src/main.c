/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include <stdint.h>




int main(void){

	uint8_t dato= 124;
	uint8_t *pDato;
	// Asignacion a pDato la direccion de memoria de dato
	pDato = &dato;
	// Casteo de pDato , convertimos el valor de dirección de memoria tipo puntero en un
	//numero común y corriente.
	// Asi direccionDato almacena como numero el valor de memoria de dato.
	uint32_t direccionDato= (uint32_t) pDato;

	// Con la siguiente estructura vemos que sobre la posicion de memoria de Dato sobreescribimos
	//el valor de 200.
	*pDato = 200;

	//Correremos 8 bits de posicion, ya que inicialmente definimos el puntero direccionando a tales tipos de datos
	//posición el puntero definido
	pDato++;

	uint8_t nuevoDato = *pDato;

	// Crear una variable de 16 bits

	uint16_t variable = 12;

	//Crear un puntero para la variable

	uint16_t *pDato2;

	//asignamos direccion de memoria

	pDato2= &variable;

	pDato2++;



	//ARREGLOS
	// Los arreglos son almacenamientos de datos del mismo tipo, el nombre del arreglo es un puntero que apunta al primer elemento del arreglo.
	// tipo_de_arreglo nombre_del_arreglo[numero de elementos]=[elemento0,elemento1,elemento2,...]

#define sizeOfArray 4

	uint8_t miPrimerArreglo[sizeOfArray] = {5,0xA,'a',254};

	//Primera forma de ingresar y recorrer un arreglo
	for (uint8_t i=0; i<sizeOfArray;i++){
		uint8_t contenido= miPrimerArreglo[i];

	}

	//sEGUNDA FORMA DE INGRESAR Y RECORRER UN ARREGLO, USANDO PUNTEROS.

	for (uint8_t i=0; i<sizeOfArray;i++){
		uint8_t contenido= *(miPrimerArreglo+i);

	}


	//ESTRUCTURAS

	//Son grupos de datos que permiten almacenar datos de distinto tipo.
	/*
	 * typedef struct{
	 *
	 *  tipodedato elemento1;
	 *  tipodedato elemento2;
	 *  tipodedato elemento3;
	 *  .
	 *  .
	 *  .
	 *
	 * }nombre_estructura_t;
	 */



	typedef struct{
		uint8_t el1;
		uint16_t el2;
		uint32_t el3;
		uint8_t arreglo[sizeOfArray];
	}miPrimeraEstructura_t;


	//Creada la estructura, podemos crear valores de tipo miPrimeraEstructura_t

	miPrimeraEstructura_t estructuraEjemeplo ={0};

	//Podemos agregar elementos a un arreglo dentro de una estructura
	estructuraEjemeplo.arreglo[0] = 'F';

	estructuraEjemeplo.el1='F';


	//Acceder a estructuras con punteros
	miPrimeraEstructura_t *pEstructura;
    /* Loop forever */
	while(1){

	}
}
